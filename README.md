# MoreDataframes
A collection of useful functions on dataframes.

![Tests](https://github.com/GlorifiedStatistics/MoreDataframes/actions/workflows/tests.yml/badge.svg)



Encode_df function:
- Takes in:
    * some values (array-like)
    * encoding information - dictionary that can either be user-made or encode_df-generated
    * multiple kwargs for extra functionality:
        1. to raise warning if there are columns that are not encoded at all (and there is no \_\_dunder__ encodings)
        2. to raise warning if there are colliding encodings (if not, then just encode both into different columns)
        3. Whether or not you want regex checking for column encodings
        4. Whether or not you want \_\_first__ and \_\_finally__ to apply to \_\_default__
- Returns:
    * Encoded values (pandas dataframe)
        1. Column names will be generated by encode_df


Encoding Dictionary:
- Should work in both the decoder as encoding_info and encoder if you want to encode other data in same manner
- Encoding keys can be either exact strings of column names (if pandas), column ints (from left to right), or regex matches for pandas column names
    * Encoding values can be either strings of builtin functions (for multiple to be applied one after the other, comma separate), or a function, or None
        2. Make sure they are pickleable somehow?
        3. Figure out if there is an easy way to add function input to string calls
    * Built-in functions:
        1. noop/None
        2. identity
        3. cast
        4. drop
        5. fillna (possibly also taking account types?)
        6. binary encode (possibly other bases)
        7. onehot-encode
        8. bin
        9. percent_bin
        10. continuous bin with flag
        11. multiple encodings (allow for multiple different encodings for same column)
    * \_\_dunder__ encoding methods:
        1. \_\_first__, \_\_default__, \_\_finally__



Pre-Encoding checklist:
1. Check if columns are not encoded or colliding encoding
1.5. Check if there are duplicate column names and fix that
2. Overwrite \_\_dunder__ encoding methods
3. Confirm encodings are possible
    * Check either are \_\_callable__ or are strings of actual functions
4. Find a working column delimiter



Applying the encoding:






Encoding function:
- Inputs: values (array-like), encoding_info (dict), inverse=False (bool), **kwargs
    * Might want to check to see if function can accept **kwargs, so it's not necesary, you would just lose access to **kwargs
- Output: encoded values (array-like)
- Side effects: any info necessary for decoding is put into encoding_info

- Should be able to take in pandas dataframe/series, numpy array, or list/tuple/anything that can
    be converted into a numpy array, or a dictionary of such values.
    * User-built ones do not necessarily need to do so
- Should return either a pandas dataframe/series, or a numpy array or anything that can be converted into a numpy array

- The actual dealing with column names will be done in the encode_df function

- Any data needed for decoding should be put into the given encoding_info dictionary. This dictionary is unique to each
    function call, so if you want something that is the same throughout each function call, wrap the function with that
    as a kwarg before using it in the encoding dictionary




TODO:
- add 'apply same to all columns' to encoding functions
- speed up chimerge